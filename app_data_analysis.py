import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport seaborn as snsfrom dateutil import parserfrom heatmap import heatmap, corrplot%matplotlib qtdf = pd.read_csv('appdata10.csv')df.head()df.describe()df['hour'] = df.hour.str.slice(0,3).astype(int)dataset = df.copy().drop(columns = ["user", 'screen_list', 'enrolled_date', 'first_open','enrolled'])plt.suptitle("Histograms of Numerical Columns")sns.set()for i in range(1,dataset.shape[1]+1):    plt.subplot(3,3,i)    plt.gca().set_title(dataset.columns[i-1])    val = np.size(dataset.iloc[:,i-1].unique())    plt.hist(dataset.iloc[:,i-1] ,bins = val, color = '#3F5D7D',edgecolor = '#3F5D7D')    #correlationdataset.corrwith(df.enrolled).plot.line()#The following correlation matrix is created by Drazen Zaric#https://www.kaggle.com/drazen/heatmap-with-sized-markersdef heatmap(x, y, **kwargs):    if 'color' in kwargs:        color = kwargs['color']    else:        color = [1]*len(x)    if 'palette' in kwargs:        palette = kwargs['palette']        n_colors = len(palette)    else:        n_colors = 256 # Use 256 colors for the diverging color palette        palette = sns.color_palette("Blues", n_colors)     if 'color_range' in kwargs:        color_min, color_max = kwargs['color_range']    else:        color_min, color_max = min(color), max(color) # Range of values that will be mapped to the palette, i.e. min and max possible correlation    def value_to_color(val):        if color_min == color_max:            return palette[-1]        else:            val_position = float((val - color_min)) / (color_max - color_min) # position of value in the input range, relative to the length of the input range            val_position = min(max(val_position, 0), 1) # bound the position betwen 0 and 1            ind = int(val_position * (n_colors - 1)) # target index in the color palette            return palette[ind]    if 'size' in kwargs:        size = kwargs['size']    else:        size = [1]*len(x)    if 'size_range' in kwargs:        size_min, size_max = kwargs['size_range'][0], kwargs['size_range'][1]    else:        size_min, size_max = min(size), max(size)    size_scale = kwargs.get('size_scale', 500)    def value_to_size(val):        if size_min == size_max:            return 1 * size_scale        else:            val_position = (val - size_min) * 0.99 / (size_max - size_min) + 0.01 # position of value in the input range, relative to the length of the input range            val_position = min(max(val_position, 0), 1) # bound the position betwen 0 and 1            return val_position * size_scale    if 'x_order' in kwargs:         x_names = [t for t in kwargs['x_order']]    else:        x_names = [t for t in sorted(set([v for v in x]))]    x_to_num = {p[1]:p[0] for p in enumerate(x_names)}    if 'y_order' in kwargs:         y_names = [t for t in kwargs['y_order']]    else:        y_names = [t for t in sorted(set([v for v in y]))]    y_to_num = {p[1]:p[0] for p in enumerate(y_names)}    plot_grid = plt.GridSpec(1, 15, hspace=0.2, wspace=0.1) # Setup a 1x10 grid    ax = plt.subplot(plot_grid[:,:-1]) # Use the left 14/15ths of the grid for the main plot    marker = kwargs.get('marker', 's')    kwargs_pass_on = {k:v for k,v in kwargs.items() if k not in [         'color', 'palette', 'color_range', 'size', 'size_range', 'size_scale', 'marker', 'x_order', 'y_order'    ]}    ax.scatter(        x=[x_to_num[v] for v in x],        y=[y_to_num[v] for v in y],        marker=marker,        s=[value_to_size(v) for v in size],         c=[value_to_color(v) for v in color],        **kwargs_pass_on    )    ax.set_xticks([v for k,v in x_to_num.items()])    ax.set_xticklabels([k for k in x_to_num], rotation=45, horizontalalignment='right')    ax.set_yticks([v for k,v in y_to_num.items()])    ax.set_yticklabels([k for k in y_to_num])    ax.grid(False, 'major')    ax.grid(True, 'minor')    ax.set_xticks([t + 0.5 for t in ax.get_xticks()], minor=True)    ax.set_yticks([t + 0.5 for t in ax.get_yticks()], minor=True)    ax.set_xlim([-0.5, max([v for v in x_to_num.values()]) + 0.5])    ax.set_ylim([-0.5, max([v for v in y_to_num.values()]) + 0.5])    ax.set_facecolor('#F1F1F1')    # Add color legend on the right side of the plot    if color_min < color_max:        ax = plt.subplot(plot_grid[:,-1]) # Use the rightmost column of the plot        col_x = [0]*len(palette) # Fixed x coordinate for the bars        bar_y=np.linspace(color_min, color_max, n_colors) # y coordinates for each of the n_colors bars        bar_height = bar_y[1] - bar_y[0]        ax.barh(            y=bar_y,            width=[5]*len(palette), # Make bars 5 units wide            left=col_x, # Make bars start at 0            height=bar_height,            color=palette,            linewidth=0        )        ax.set_xlim(1, 2) # Bars are going from 0 to 5, so lets crop the plot somewhere in the middle        ax.grid(False) # Hide grid        ax.set_facecolor('white') # Make background white        ax.set_xticks([]) # Remove horizontal ticks        ax.set_yticks(np.linspace(min(bar_y), max(bar_y), 3)) # Show vertical ticks for min, middle and max        ax.yaxis.tick_right() # Show vertical ticks on the right def corrplot(data, size_scale=500, marker='s'):    corr = pd.melt(data.reset_index(), id_vars='index')    corr.columns = ['x', 'y', 'value']    heatmap(        corr['x'], corr['y'],        color=corr['value'], color_range=[-1, 1],        palette=sns.diverging_palette(20, 220, n=256),        size=corr['value'].abs(), size_range=[0,1],        marker=marker,        x_order=data.columns,        y_order=data.columns[::-1],        size_scale=size_scale    )corr = dataset.corr()plt.figure(figsize=(10, 10))ax = sns.heatmap(    corr,     vmin=-1, vmax=1, center=0,    cmap=sns.diverging_palette(20, 220, n=200),    square=True)ax.set_xticklabels(    ax.get_xticklabels(),    rotation=45,    horizontalalignment='right')ax.set_title('Correlation Matrix', size = 20)#Feature Engineeringdf['first_open'] = [parser.parse(row_data) for row_data in df['first_open']]df['enrolled_date'] = [parser.parse(row_data) if isinstance(row_data, str) else row_data for row_data in df['enrolled_date']]df['difference'] = (df.enrolled_date - df.first_open).astype('timedelta64[h]')df.info()plt.hist(df['difference'].dropna(), range(0,20))plt.title("Distribution of Time-Since-Enrolled")plt.show()df.loc[df.difference > 48, 'enrolled'] = 0df = df.drop(columns = ['difference','enrolled_date','first_open'])top_screens = pd.read_csv('top_screens.csv').top_screens.valuesdf['screen_list'] = df.screen_list.astype(str)+','for sc in top_screens:    df[sc] = df.screen_list.str.contains(sc).astype(int)    df["screen_list"] = df.screen_list.str.replace(sc+',','')df['Other'] = df.screen_list.str.count(',')df = df.drop(columns = ['screen_list'])savings_screens = ["Saving1",                    "Saving2",                    "Saving2Amount",                    "Saving4",                    "Saving5",                    "Saving6",                    "Saving7",                    "Saving8",                    "Saving9",                    "Saving10"]df["SavingCount"] = df[savings_screens].sum(axis=1)df = df.drop(columns=savings_screens)cm_screens = ["Credit1",               "Credit2",               "Credit3",               "Credit3Container",               "Credit3Dashboard"]df["CMCount"] = df[cm_screens].sum(axis=1)df = df.drop(columns=cm_screens)cc_screens = ["CC1",                "CC1Category",                "CC3"]df["CCCount"] = df[cc_screens].sum(axis=1)df = df.drop(columns=cc_screens)loan_screens = ["Loan",               "Loan2",               "Loan3",               "Loan4"]df["LoansCount"] = df[loan_screens].sum(axis=1)df = df.drop(columns=loan_screens)df.columnsdf.to_csv('new_appdata10.csv', index = False)